'use strict';import * as ws from './websocket.js';import * as mouse from './mouse.js';import * as page from './page.js';import * as login from './login.js';import * as client_context from './client_context.js';var elem = document.getElementById('draw-shapes');const viewport = document.getElementById('viewport');let scores_box = null;const params = {width: 1, height: 1};const two = new Two(params).appendTo(viewport);const table_state = {players: {}, foods: {}, events: []};function make_css_color(color, alpha = 1.0) {  const r = Math.floor(color[0] * 255).toString(16).padStart(2, '0');  const g = Math.floor(color[1] * 255).toString(16).padStart(2, '0');  const b = Math.floor(color[2] * 255).toString(16).padStart(2, '0');  const a = Math.floor(alpha * 255).toString(16).padStart(2, '0');  return '#' + r + g + b + a;}function on_websocket_message(message) {  if (message.command === 'update_table_state') {    const scale = viewport.offsetWidth;    let scores_box_contents_changed = (scores_box === null) || (message.state.events.length > 0);    mouse.enable_mouse_messages(true);    // delete any players and food that no longer exist    for (const [name, local_player] of Object.entries(table_state.players)) {      if (message.state.players[name] === undefined) {        two.remove(local_player.head_obj);        for (const line of local_player.tail_line_objs) {          two.remove(line);        }        delete table_state.players[name];        scores_box_contents_changed = true;      }    }    for (const [id, local_food] of Object.entries(table_state.foods)) {      if (message.state.foods[id] === undefined) {        two.remove(local_food.head_obj);        delete table_state.foods[id];        scores_box_contents_changed = true;      }    }    for (const [name, player] of Object.entries(message.state.players)) {      // update local player state      let local_player;      if (table_state.players[name] === undefined) {        const head_obj = two.makeCircle(player.x * scale, player.y * scale, player.r * scale);        local_player = {          head_obj,          tail_line_objs: [],        };        table_state.players[name] = local_player;        scores_box_contents_changed = true;      } else {        local_player = table_state.players[name];      }      Object.assign(local_player, player);      // update graphical objects      local_player.head_obj.translation.set(local_player.x * scale, local_player.y * scale);      local_player.head_obj.fill = make_css_color(local_player.color, local_player.invincible ? 0.5 : 1.0);      local_player.head_obj.stroke = make_css_color(local_player.color);      for (const line of local_player.tail_line_objs) {        two.remove(line);      }      let prev_point = [message.state.server_time, local_player.x, local_player.y];      const path_lines = [];      for (const tail_point of local_player.tail_points) {        const line = two.makeLine(            tail_point[1] * scale, tail_point[2] * scale,            prev_point[1] * scale, prev_point[2] * scale);        const opacity = 1.0 - ((message.state.server_time - tail_point[0]) / message.state.tail_lifespan);        line.stroke = make_css_color(player.color, opacity);        line.linewidth = 0.004 * scale;        local_player.tail_line_objs.push(line);        prev_point = tail_point;      }    }    for (const [id, food] of Object.entries(message.state.foods)) {      // update local food state      let local_food;      if (table_state.foods[id] === undefined) {        const head_obj = two.makeCircle(food.x * scale, food.y * scale, food.r * scale);        head_obj.fill = make_css_color(food.color);        local_food = {head_obj};        table_state.foods[id] = local_food;        scores_box_contents_changed = true;      } else {        local_food = table_state.foods[id];      }      Object.assign(local_food, food);      // update graphical objects      local_food.head_obj.translation.set(local_food.x * scale, local_food.y * scale);    }    // bring in new events    for (const event of message.state.events) {      const local_player = table_state.players[event.player_name];      const text_obj = new Two.Text(event.score.toString(), event.x * scale, event.y * scale);      text_obj.family = 'sans-serif';      text_obj.size = 12;      text_obj.style = 'italic';      text_obj.fill = make_css_color(local_player.color);      two.add(text_obj);      const local_event = {        ...event,        text_obj,        create_time: new Date().getTime(),      };      table_state.events.push(local_event);    }    // delete text objects that are too old (1.5 seconds)    {      const cutoff_time = new Date().getTime() - 1500;      const kept_events = [];      for (const local_event of table_state.events) {        if (local_event.create_time < cutoff_time) {          two.remove(local_event.text_obj);        } else {          kept_events.push(local_event);        }      }      table_state.events = kept_events;    }    two.width = viewport.offsetWidth;    two.height = viewport.offsetHeight;    two.update();    if (scores_box_contents_changed) {      if (scores_box !== null) {        document.body.removeChild(scores_box);      }      const scores_list = [];      for (const [name, local_player] of Object.entries(table_state.players)) {        scores_list.push([name, local_player.color, local_player.score]);      }      scores_list.sort((a, b) => {        if (a[2] < b[2]) {          return 1;        } else if (a[2] > b[2]) {          return -1;        } else {          return 0;        }      });      const scores_box_contents = [page.u('Scores')];      for (const [name, color, score] of scores_list) {        scores_box_contents.push(page.br());        scores_box_contents.push(page.span({style: 'color: ' + make_css_color(color)}, `(${score}) ${name}`));      }      scores_box = page.div({class: 'scores_box'}, scores_box_contents);      page.add(scores_box);    }  } else if (message.command === 'error') {    show_error(message.message);  } else {    console.log('unhandled websocket message', message);  }}function show_error(text) {  document.body.removeChild(viewport);  if (scores_box !== null) {    document.body.removeChild(scores_box);    scores_box = null;  }  page.add(page.div({class: 'error_box'}, [    page.text(text),    page.br(),    page.a({class: 'error_reload', href: '/'}, '&#x27f3;'),  ]));}function on_websocket_disconnect() {  show_error('The server has disconnected.');}mouse.enable_mouse_messages(false);viewport.addEventListener('mousemove', mouse.on_viewport_mousemove);ws.connect(null, on_websocket_disconnect, on_websocket_message);login.create(viewport);